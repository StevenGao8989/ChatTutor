# ChatTutor 核心链路文档

## 目录
- [系统架构概览](#系统架构概览)
- [核心业务流程](#核心业务流程)
- [文件结构映射](#文件结构映射)
- [详细代码链路](#详细代码链路)
- [数据流向图](#数据流向图)
- [关键技术点](#关键技术点)

---

## 系统架构概览

ChatTutor 是一个基于 **FastAPI** 的 Web 应用，采用前后端分离架构，通过 **Server-Sent Events (SSE)** 实现流式数据传输。

```
┌─────────────────┐
│   用户浏览器     │
│  (Frontend)     │
└────────┬────────┘
         │ HTTP/SSE
         │
┌────────▼────────┐
│   FastAPI 后端   │
│   (Backend)     │
└────────┬────────┘
         │ API 调用
         │
┌────────▼────────┐
│   LLM API       │
│ (Gemini/OpenAI) │
└─────────────────┘
```

---

## 核心业务流程

### 完整流程时序图

```
用户 → 前端界面 → 后端API → LLM服务 → 后端处理 → 前端渲染 → 用户看到动画

1. 用户输入主题
2. 前端发送POST请求
3. 后端调用LLM生成HTML代码
4. 流式返回代码片段
5. 前端实时接收并累积
6. 检测到完整HTML代码块
7. 在iframe中渲染动画
8. 用户看到生成的动画
```

### 核心链路步骤

1. **用户交互层** (`templates/index.html` + `static/script.js`)
2. **API请求层** (`static/script.js` → `app.py`)
3. **LLM调用层** (`app.py` → LLM API)
4. **流式传输层** (`app.py` → `static/script.js`)
5. **代码解析层** (`static/script.js`)
6. **动画渲染层** (`static/script.js` → iframe)

---

## 文件结构映射

### 核心文件清单

| 文件路径 | 功能模块 | 关键作用 |
|---------|---------|---------|
| `app.py` | 后端核心 | FastAPI应用、LLM调用、SSE流式传输 |
| `templates/index.html` | 前端界面 | HTML结构、UI模板、消息模板 |
| `static/script.js` | 前端逻辑 | 用户交互、API调用、代码解析、动画渲染 |
| `static/style.css` | 前端样式 | UI样式、动画效果 |
| `start_fogsight.py` | 启动脚本 | 服务启动、浏览器自动打开 |
| `credentials.json` | 配置文件 | API密钥、模型配置 |
| `requirements.txt` | 依赖管理 | Python包依赖 |
| `Dockerfile` | 容器化 | Docker镜像构建 |
| `docker-compose.yml` | 容器编排 | Docker Compose配置 |

---

## 详细代码链路

### 1. 用户输入阶段

**文件**: `templates/index.html` + `static/script.js`

**流程**:
```javascript
// static/script.js:72-92
function handleFormSubmit(e) {
    e.preventDefault();
    const topic = input.value.trim();
    if (!topic) return;
    
    // 切换到聊天视图
    if (isInitial) switchToChatView();
    
    // 添加到对话历史
    conversationHistory.push({ role: 'user', content: topic });
    
    // 开始生成
    startGeneration(topic);
}
```

**关键代码位置**:
- `static/script.js:72-92` - 表单提交处理
- `static/script.js:213-218` - 视图切换逻辑
- `templates/index.html:30-36` - 初始表单
- `templates/index.html:54-61` - 聊天表单

---

### 2. API 请求阶段

**文件**: `static/script.js`

**流程**:
```javascript
// static/script.js:94-112
async function startGeneration(topic) {
    // 显示用户消息
    appendUserMessage(topic);
    
    // 显示"思考中"状态
    appendAgentStatus(translations.agentThinking[currentLang]);
    
    // 发送POST请求到后端
    const response = await fetch(`${config.apiBaseUrl}/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            topic: topic, 
            history: conversationHistory 
        })
    });
}
```

**关键代码位置**:
- `static/script.js:94-211` - 生成流程主函数
- `static/script.js:108-112` - Fetch API 调用

**请求格式**:
```json
{
    "topic": "冒泡排序",
    "history": [
        { "role": "user", "content": "..." },
        { "role": "assistant", "content": "..." }
    ]
}
```

---

### 3. 后端接收与处理阶段

**文件**: `app.py`

**流程**:
```python
# app.py:153-186
@app.post("/generate")
async def generate(chat_request: ChatRequest, request: Request):
    """
    Main endpoint: POST /generate
    Accepts a JSON body with "topic" and optional "history".
    Returns an SSE stream.
    """
    async def event_generator():
        async for chunk in llm_event_stream(
            chat_request.topic, 
            chat_request.history
        ):
            if await request.is_disconnected():
                break
            yield chunk
    
    return StreamingResponse(
        event_generator(), 
        headers={
            "Content-Type": "text/event-stream; charset=utf-8",
            "Cache-Control": "no-store",
            "X-Accel-Buffering": "no",
        }
    )
```

**关键代码位置**:
- `app.py:153-186` - `/generate` 路由处理
- `app.py:68-70` - `ChatRequest` 数据模型

---

### 4. LLM 调用阶段

**文件**: `app.py`

**流程**:
```python
# app.py:75-148
async def llm_event_stream(
    topic: str,
    history: Optional[List[dict]] = None,
    model: str = None,
) -> AsyncGenerator[str, None]:
    # 构建系统提示词
    system_prompt = f"""请你生成一个非常精美的动态动画,讲讲 {topic}
    要动态的,要像一个完整的,正在播放的视频...
    html+css+js+svg，放进一个html里"""
    
    if USE_GEMINI:
        # Gemini API 调用
        response = await asyncio.get_event_loop().run_in_executor(
            None, 
            lambda: gemini_client.models.generate_content(
                model=model, 
                contents=full_prompt
            )
        )
        # 分块流式返回
        for i in range(0, len(text), chunk_size):
            chunk = text[i:i+chunk_size]
            yield f"data: {json.dumps({'token': chunk})}\n\n"
    else:
        # OpenAI 兼容 API 调用
        response = await client.chat.completions.create(
            model=model,
            messages=messages,
            stream=True,
            temperature=0.8,
        )
        async for chunk in response:
            token = chunk.choices[0].delta.content or ""
            yield f"data: {json.dumps({'token': token})}\n\n"
    
    yield 'data: {"event":"[DONE]"}\n\n'
```

**关键代码位置**:
- `app.py:75-148` - LLM流式生成器
- `app.py:30-48` - API客户端初始化
- `app.py:87-94` - 系统提示词构建

**API配置**:
- `app.py:25-28` - 从 `credentials.json` 读取配置
- `app.py:30-48` - 根据API_KEY判断使用Gemini还是OpenAI兼容API

---

### 5. 流式数据接收阶段

**文件**: `static/script.js`

**流程**:
```javascript
// static/script.js:116-189
const reader = response.body.getReader();
const decoder = new TextDecoder();
let buffer = '';

while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    
    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n\n');
    buffer = lines.pop();
    
    for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        
        const jsonStr = line.substring(6);
        
        // 检测结束标记
        if (jsonStr.includes('[DONE]')) {
            // 处理完成
            break;
        }
        
        const data = JSON.parse(jsonStr);
        const token = data.token || '';
        
        // 检测代码块开始
        if (!inCodeBlock && token.includes('```')) {
            inCodeBlock = true;
            codeBlockElement = appendCodeBlock();
        }
        
        // 累积代码
        if (inCodeBlock) {
            updateCodeBlock(codeBlockElement, token);
        }
    }
}
```

**关键代码位置**:
- `static/script.js:116-189` - SSE流式读取
- `static/script.js:173-187` - 代码块检测与累积
- `static/script.js:239-255` - 代码块更新

**数据格式**:
```
data: {"token":"```html\n"}
data: {"token":"<html>"}
data: {"token":"..."}
data: {"event":"[DONE]"}
```

---

### 6. 代码解析与验证阶段

**文件**: `static/script.js`

**流程**:
```javascript
// static/script.js:132-158
if (jsonStr.includes('[DONE]')) {
    // 添加到对话历史
    conversationHistory.push({ 
        role: 'assistant', 
        content: accumulatedCode 
    });
    
    // 验证代码块是否存在
    if (!codeBlockElement) {
        throw new LLMParseError('LLM did not return a complete code block.');
    }
    
    // 验证HTML内容有效性
    if (!isHtmlContentValid(accumulatedCode)) {
        throw new LLMParseError('Invalid HTML content received.');
    }
    
    // 标记代码完成
    markCodeAsComplete(codeBlockElement);
    
    // 渲染动画
    appendAnimationPlayer(accumulatedCode, topic);
}
```

**关键代码位置**:
- `static/script.js:132-158` - 完成处理逻辑
- `static/script.js:295-313` - HTML内容验证
- `static/script.js:257-260` - 代码完成标记

**验证函数**:
```javascript
// static/script.js:295-313
function isHtmlContentValid(htmlContent) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(htmlContent, "text/html");
    
    // 检查解析错误
    const parseErrors = doc.querySelectorAll("parsererror");
    if (parseErrors.length > 0) return false;
    
    // 检查内容是否为空
    if (!doc.body || doc.body.innerHTML.trim() === "") {
        return false;
    }
    
    return true;
}
```

---

### 7. 动画渲染阶段

**文件**: `static/script.js` + `templates/index.html`

**流程**:
```javascript
// static/script.js:262-293
function appendAnimationPlayer(htmlContent, topic) {
    // 克隆播放器模板
    const node = templates.player.content.cloneNode(true);
    const playerElement = node.firstElementChild;
    
    // 设置iframe内容
    const iframe = playerElement.querySelector('.animation-iframe');
    iframe.srcdoc = htmlContent;
    
    // 绑定操作按钮事件
    playerElement.querySelector('.open-new-window')
        .addEventListener('click', () => {
            const blob = new Blob([htmlContent], { type: 'text/html' });
            window.open(URL.createObjectURL(blob), '_blank');
        });
    
    playerElement.querySelector('.save-html')
        .addEventListener('click', () => {
            // 下载HTML文件
            const blob = new Blob([htmlContent], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${topic.replace(/\s/g, '_')}.html`;
            a.click();
        });
    
    // 添加到聊天日志
    chatLog.appendChild(playerElement);
    scrollToBottom();
}
```

**关键代码位置**:
- `static/script.js:262-293` - 动画播放器创建
- `templates/index.html:104-124` - 播放器模板
- `static/script.js:315` - 滚动到底部

**模板结构**:
```html
<!-- templates/index.html:104-124 -->
<template id="animation-player-template">
    <div class="message-group agent has-player">
        <div class="player-container">
            <div class="iframe-wrapper">
                <iframe class="animation-iframe" 
                        sandbox="allow-scripts allow-same-origin">
                </iframe>
            </div>
            <div class="player-actions">
                <button class="action-button open-new-window">...</button>
                <button class="action-button save-html">...</button>
                <button class="action-button export-video">...</button>
            </div>
        </div>
    </div>
</template>
```

---

## 数据流向图

### 完整数据流

```
┌─────────────────────────────────────────────────────────────┐
│                        用户浏览器                             │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  [index.html]          [script.js]          [style.css]      │
│      │                     │                     │            │
│      │  HTML结构           │  JavaScript逻辑     │  样式定义  │
│      │                     │                     │            │
│      └─────────┬───────────┴─────────────────────┘            │
│                │                                              │
│                │ 1. 用户输入主题                              │
│                │ 2. POST /generate                            │
│                │ 3. 接收SSE流                                 │
│                │ 4. 解析代码块                                 │
│                │ 5. 渲染iframe                                │
│                │                                              │
└────────────────┼──────────────────────────────────────────────┘
                 │ HTTP/SSE
                 │
┌────────────────▼──────────────────────────────────────────────┐
│                      FastAPI 后端                              │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  [app.py]                                                     │
│      │                                                        │
│      │ 1. 接收POST请求                                        │
│      │ 2. 解析ChatRequest                                     │
│      │ 3. 调用llm_event_stream()                             │
│      │ 4. 构建系统提示词                                       │
│      │ 5. 调用LLM API                                         │
│      │ 6. 流式返回SSE数据                                     │
│      │                                                        │
└──────┼────────────────────────────────────────────────────────┘
       │ API调用
       │
┌──────▼────────────────────────────────────────────────────────┐
│                    LLM API 服务                                │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  Gemini API 或 OpenAI 兼容 API                                │
│      │                                                        │
│      │ 1. 接收提示词和对话历史                                 │
│      │ 2. 生成HTML+CSS+JS+SVG代码                             │
│      │ 3. 流式返回token                                       │
│      │                                                        │
└───────────────────────────────────────────────────────────────┘
```

### 关键数据结构

**请求数据** (`ChatRequest`):
```python
# app.py:68-70
class ChatRequest(BaseModel):
    topic: str                    # 用户输入的主题
    history: Optional[List[dict]] # 对话历史（可选）
```

**SSE数据格式**:
```json
// 代码token
{"token": "```html\n"}

// 完成标记
{"event": "[DONE]"}

// 错误信息
{"error": "错误描述"}
```

**对话历史格式**:
```python
[
    {"role": "user", "content": "冒泡排序"},
    {"role": "assistant", "content": "<html>...</html>"},
    {"role": "user", "content": "请修改颜色"}
]
```

---

## 关键技术点

### 1. Server-Sent Events (SSE)

**位置**: `app.py:186`, `static/script.js:116-189`

**作用**: 实现服务器到客户端的单向流式数据传输

**关键代码**:
```python
# app.py:181-186
headers = {
    "Content-Type": "text/event-stream; charset=utf-8",
    "Cache-Control": "no-store",
    "X-Accel-Buffering": "no",
}
return StreamingResponse(wrapped_stream(), headers=headers)
```

### 2. 异步流式生成器

**位置**: `app.py:75-148`

**作用**: 使用Python异步生成器实现流式数据输出

**关键代码**:
```python
async def llm_event_stream(...) -> AsyncGenerator[str, None]:
    # ...
    yield f"data: {json.dumps({'token': chunk})}\n\n"
```

### 3. 代码块检测与累积

**位置**: `static/script.js:173-187`

**作用**: 检测Markdown代码块标记（```），累积完整HTML代码

**关键逻辑**:
- 检测 ```` 开始标记
- 累积中间内容
- 检测 ```` 结束标记
- 提取完整HTML代码

### 4. iframe沙箱渲染

**位置**: `static/script.js:262-293`, `templates/index.html:107`

**作用**: 在沙箱iframe中安全渲染用户生成的HTML代码

**关键代码**:
```html
<iframe class="animation-iframe" 
        sandbox="allow-scripts allow-same-origin">
</iframe>
```

```javascript
iframe.srcdoc = htmlContent;
```

### 5. 对话历史管理

**位置**: `static/script.js:68`, `static/script.js:88`, `static/script.js:134`

**作用**: 维护多轮对话上下文，支持迭代优化

**数据结构**:
```javascript
let conversationHistory = [
    { role: 'user', content: '...' },
    { role: 'assistant', content: '...' }
];
```

### 6. 错误处理机制

**位置**: `static/script.js:60-66`, `static/script.js:190-204`

**作用**: 统一的错误处理和用户提示

**错误类型**:
- `LLMParseError` - LLM解析错误
- `TypeError` - 网络请求失败
- HTTP状态码错误（如429限流）

### 7. 多语言支持

**位置**: `static/script.js:7-36`, `static/script.js:336-353`

**作用**: 支持中英文界面切换

**实现方式**:
- 翻译字典存储
- `data-translate-key` 属性标记
- 动态更新文本内容

### 8. 视图状态管理

**位置**: `static/script.js:213-218`, `templates/index.html:17-19`

**作用**: 管理初始视图和聊天视图的切换

**实现方式**:
```css
/* static/style.css:17-19 */
body.show-initial-view .initial-view { display: flex; }
body.show-chat-view .chat-view { display: flex; }
```

---

## 核心文件功能总结

### `app.py` - 后端核心
- ✅ FastAPI应用初始化
- ✅ CORS中间件配置
- ✅ 静态文件服务
- ✅ API密钥和客户端初始化
- ✅ `/generate` POST路由
- ✅ `/` GET路由（首页）
- ✅ LLM流式生成器
- ✅ Gemini和OpenAI兼容API支持

### `templates/index.html` - 前端界面
- ✅ HTML页面结构
- ✅ 初始视图和聊天视图
- ✅ 消息模板（用户、状态、代码、播放器、错误）
- ✅ 语言切换器
- ✅ 模态框组件

### `static/script.js` - 前端逻辑
- ✅ 表单提交处理
- ✅ Fetch API调用
- ✅ SSE流式数据接收
- ✅ 代码块检测与累积
- ✅ HTML内容验证
- ✅ 动画播放器创建
- ✅ 文件下载功能
- ✅ 对话历史管理
- ✅ 错误处理
- ✅ 多语言支持
- ✅ 视图切换

### `static/style.css` - 前端样式
- ✅ 全局样式定义
- ✅ 响应式布局
- ✅ 动画效果
- ✅ 消息气泡样式
- ✅ 代码块样式
- ✅ 播放器样式

### `start_fogsight.py` - 启动脚本
- ✅ 后端服务启动
- ✅ 浏览器自动打开
- ✅ 多线程管理

---

## 关键配置点

### API配置 (`credentials.json`)
```json
{
    "API_KEY": "your-api-key",
    "BASE_URL": "https://openrouter.ai/api/v1",  // 或空字符串（Gemini）
    "MODEL": "gemini-2.5-pro"  // 或 "anthropic/claude-sonnet-4"
}
```

### 系统提示词 (`app.py:87-94`)
- 要求生成精美的动态动画
- 包含完整知识点讲解
- 使用HTML+CSS+JS+SVG
- 双语字幕
- 2K分辨率优化

### 流式传输参数
- Gemini: 分块大小50字符，延迟0.05秒
- OpenAI兼容: 实时流式，延迟0.001秒

---

## 扩展点

### 1. 添加新的LLM提供商
- 修改 `app.py:30-48` 的API客户端初始化逻辑
- 在 `app.py:96-122` 或 `app.py:123-146` 添加新的API调用分支

### 2. 自定义系统提示词
- 修改 `app.py:87-94` 的 `system_prompt` 变量

### 3. 添加新的UI功能
- 在 `templates/index.html` 添加新的模板
- 在 `static/script.js` 添加对应的处理逻辑
- 在 `static/style.css` 添加样式

### 4. 优化错误处理
- 扩展 `static/script.js:60-66` 的错误类型
- 在 `static/script.js:190-204` 添加更多错误场景处理

---

**文档版本**: 1.0  
**最后更新**: 2024  
**维护者**: ChatTutor 开发团队
